---
layout: post
title:  "13-(3) RAG 시스템에서 'Agent'는 어떤 개념인지, 어떻게 구현할 수 있는지 구글 등에서 리서치하여 정리해보세요."
date:   2025-09-05 13:00:00 +0900
categories: [Codeit AI 3기, Weekly Paper]
tags: [RAG, Agent, LangChain, PEFT, BERT, GPT, NLP, LLM, Trasnformer, Deep Learning, AI]
comments: true     # 댓글 기능 사용 (옵션)
image:
    path: https://www.solulab.com/wp-content/uploads/2024/07/rag.jpg

---
## 🟢 RAG 시스템에서 'Agent'

앞서 RAG에 대한 개념을 정리했고 이제 **Agent**까지 얘기 들어가면 좀 더 “자율적인” RAG 시스템으로 확장되는 거라고 볼 수 있다.

RAG 시스템에서 **Agent**는 단순히 주어진 문서를 검색해서 답변하는 것을 넘어, **스스로 생각하고, 계획을 세우고, 다양한 '도구(Tools)'를 사용하여 문제를 해결하는 자율적인 주체**를 의미한다.

---

#### ⚪ Agent의 핵심 개념: 추론하고 행동하기 (Reasoning & Acting)

Agent의 가장 큰 특징은 LLM을 단순히 답변 생성기가 아니라, **'추론 엔진(Reasoning Engine)'**으로 사용한다는 점입니다.

1.  **사고 (Thought)**: 사용자의 복잡한 질문을 받으면, Agent는 먼저 최종 목표를 달성하기 위해 어떤 단계들을 거쳐야 할지 **계획을 세웁니다.**
2.  **행동 (Action)**: 계획에 따라, 현재 단계에서 가장 적절한 **'도구(Tool)'**를 선택합니다.
3.  **도구 입력 (Action Input)**: 선택한 도구에 필요한 입력값을 결정하여 전달합니다.
4.  **관찰 (Observation)**: 도구를 실행한 결과를 **관찰**합니다.
5.  **반복**: 관찰한 결과를 바탕으로 다음 행동을 결정하거나, 목표를 달성했다고 판단하면 최종 답변을 생성합니다.

이 **'사고 → 행동 → 관찰'**의 순환 과정을 **ReAct(Reasoning and Acting)** 프레임워크라고 하며, 대부분의 Agent가 이 원리를 기반으로 작동합니다.



---
#### ⚪ RAG vs. Agentic RAG..

![agent](https://miro.medium.com/v2/resize:fit:720/format:webp/0*jwI8dk9XvTzhFd7d.jpg)

* **기본 RAG**:
  사용자의 질문 → Retriever로 문서 검색 → LLM이 답변 생성

  👉 단순한 **retrieval + generation 파이프라인**

* **RAG + Agent**:
  LLM이 단순히 답변만 하는 게 아니라,
  “어떤 액션을 취할지 스스로 결정하고, 도구(tool)를 호출하고, 다시 reasoning 하는 구조”
  
  👉 즉, **LLM이 orchestrator(조율자)** 역할을 하는 것


* **Agent의 역할**:

  1. **질문 이해** → 어떤 도구가 필요한지 판단
  2. **도구 호출 (예: retriever, calculator, API 등)**
  3. **결과 해석** → 다시 LLM에게 reasoning 시킴
  4. **최종 답변 생성**

LangChain에서 Agent는 보통 **LLM + Tools + Policy**의 조합으로 구현됨.

---
#### ⚪ Agent가 필요한 이유

* 단순 Q&A가 아니라, **복합적인 워크플로우**가 필요할 때 유용
* 예:
  * 검색 + 계산 조합 ("2022년 매출은 얼마고, 전년 대비 성장률은?")
  * 여러 retriever 중 적절한 데이터 소스 선택
  * 외부 API 호출 + 결과 reasoning

---



#### ⚪ Agent 구현 방법 (LangChain 기준)

##### 1. **필요 요소**

* **LLM**: 의사결정 주체 (예: GPT-4)
* **Tools**: 외부 액션 실행 도구 (retriever, DB, API, 계산기 등)
* **Agent Policy**: 어떤 상황에서 어떤 tool을 사용할지 결정하는 규칙 (보통 LLM의 prompt로 학습됨)

---

##### 2. **간단한 예시 코드**

```python
from langchain.llms import OpenAI
from langchain.agents import initialize_agent, Tool
from langchain.chains import RetrievalQA
from langchain.vectorstores import FAISS

# 1. LLM 정의
llm = OpenAI(temperature=0)

# 2. Retriever 정의 (RAG용)
retriever = FAISS.load_local("my_vectorstore").as_retriever()
retrieval_chain = RetrievalQA.from_chain_type(llm=llm, retriever=retriever)

# 3. Tool로 등록
tools = [
    Tool(
        name="Knowledge Base",
        func=retrieval_chain.run,
        description="유저 질문에 답하기 위해 문서 검색이 필요할 때 사용"
    )
]

# 4. Agent 초기화
agent = initialize_agent(
    tools,
    llm,
    agent="zero-shot-react-description",  # ReAct 기반 정책
    verbose=True
)

# 5. Agent 실행
response = agent.run("우리 회사의 제품 X에 대한 고객 피드백은 어때?")
print(response)
```

👉 여기서 agent는 질문을 보고 **retriever를 호출할지, 그냥 LLM으로 답할지** 스스로 결정함.

---


## 🟢 정리

* **기본 RAG** = retriever + LLM (직선 파이프라인)
* **RAG + Agent** = LLM이 \*\*도구(tool)\*\*를 적절히 선택·호출하며 reasoning (자율성↑)
* **구현**: LangChain `Agent` → `LLM + Tools + Policy` 구조
* **장점**: 복잡한 질의 처리, multi-step reasoning 가능


이처럼 RAG 시스템에 Agent 개념을 도입하면, 단순히 저장된 문서의 내용을 넘어 **다양한 소스로부터 정보를 동적으로 결합**하여 훨씬 더 복잡하고 유용한 질문에 답할 수 있는 고도화된 시스템을 만들 수 있습니다.



## 🟢 예시 답안 (코드잇 제공)


>RAG 시스템에서 'Agent'는 단순히 질문에 대한 검색과 답변 생성만 수행하는 고정된 흐름이 아니라, 질문을 이해하고 상황에 따라 필요한 행동을 스스로 결정하며 여러 단계를 유연하게 수행할 수 있는 실행 주체입니다.<br>예를 들어, 일반적인 RAG 시스템은 사용자의 질문을 받으면 관련 문서를 검색하고, 그 내용을 바탕으로 답변을 생성하는 정해진 구조를 따릅니다. 하지만 어떤 질문은 단순하지 않고, 질문을 쪼개거나, 여러 정보를 종합하거나, 추가적인 판단이 필요한 경우가 많습니다. 이럴 때 Agent는 질문의 목적을 이해하고, 어떤 도구를 언제 사용해야 할지 스스로 판단하며, 검색 → 요약 → 비교 → 응답 생성 같은 복합적인 과정을 순차적으로 수행할 수 있습니다.<br>Agent는 일종의 '지능형 문제 해결자'라고 보면 됩니다. LLM을 기반으로 하고, 다양한 도구와 상호작용하면서 복잡한 태스크를 해결하는 구조죠.<br><br>Agent를 구현하려면 다음과 같은 요소가 필요합니다.<br><br>첫째, 언어 모델(LLM)이 핵심입니다. Agent는 LLM을 기반으로 사용자의 질문을 분석하고 다음 행동을 결정합니다.<br>둘째, Tool 또는 Function이 필요합니다. 예를 들어 검색기, 계산기, 데이터베이스 조회기, 요약기 같은 기능이 대표적입니다. Agent는 이 도구들을 상황에 따라 호출해서 결과를 얻고, 다시 다음 행동으로 이어갑니다.<br>셋째, 메모리(Memory) 기능이 있다면 더 유용합니다. 이전 질문이나 중간 결과를 기억하고 활용할 수 있어 더 자연스럽고 일관성 있는 작업이 가능해집니다.<br><br>LangChain 같은 프레임워크에서는 Agent를 구현하는 기능을 기본적으로 지원합니다. initialize_agent 함수로 LLM과 사용할 도구들을 등록하고, 어떤 스타일의 Agent를 사용할지 정의하면 됩니다. 예를 들어, 검색기와 요약기를 도구로 등록해 두면, Agent가 사용자의 질문에 따라 먼저 검색을 하고, 그 결과를 요약한 뒤 최종 응답을 만드는 식으로 자동으로 동작하게 만들 수 있습니다.<br><br>정리하면, RAG 시스템에서 Agent는 단순한 검색-생성 구조를 넘어서 질문을 해석하고, 적절한 전략을 스스로 선택하며, 필요한 작업을 단계적으로 수행할 수 있는 유연한 실행 엔진이라고 할 수 있습니다. Agent가 들어가면 RAG 시스템은 훨씬 더 복잡한 질의에도 유연하게 대응할 수 있습니다.